P = P + Q + K %*% R %*% t(K) # MSE estimate
return(list("x" = x, "P" = P)) # Store the results to be returned when calling the function as a list (we do this because R functions return one result)
}
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the Kalman filtration results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600
T = nrow(y)
n = ncol(y)
# Kalman preliminaries. The notation follows Chapter 13 of Hamilton, J.D.
# (1994). Time Series Analysis. with the exception of H, which is equivalent
# to his H'.
q = 1 / lambda # the signal-to-noise ration: i.e. var eta_t / var epsilon_t
F = rbind(c(2,-1),c(1,0)) # The state transition matrix
H = rbind(c(1,0)) # The observation matrix
Q = rbind(c(q,0),c(0,0)) # The variance-covariance matrix of the errors in the state equation
R = 1 # The variance of the error in the observation equation
for (k in 1:n) { # Run the Kalman filter for each variable
if (nargs() < 4 | exists("x_user")=="FALSE" | is.null(x_user)) {x = rbind(unlist(c(2*y[1,k]-y[2,k])), unlist(c(3*y[1,k]-2*y[2,k])))} else {x = x_user[,k]} # If the user didn't provide an initial value for state estimate, extrapolate back two periods from the observations
if (nargs() < 4 | exists("P_user")=="FALSE" | is.null(P_user)) {P = rbind(c(1e5, 0), c(0,1e5))} else {P = P_user[k]} # If the user didn't provide an intial value for the MSE, set a relatively high one
for (j in 1:T) { # Get the estimates for each period
klm = kalman_update(y,F,H,Q,R,j,k,x,P) # store the results returned by the function as a list called "klm"
x = klm$x # get element "x" from the list called "klm" and store it as "x" so that it can be used outside the function kalman_update
P = klm$P # similarly to x
ytrend[j,k]=x[2] # The second element of the state is the estimate of the trend
}
}
ycycle = y - ytrend # Deviations from the HP trend
if (!missing(discard)) { # If the user provided a discard parameter
ytrend = ytrend[-1:-discard,] # Remove the first "discard" periods from the trend series
ycycle = ycycle[-1:-discard,] # The second output will be the deviations from the HP trend, likewise with  first "discard" periods removed
}
ytrend <- as.data.frame(ytrend) # Store "ytrend" as a tibble
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
ytrend1 <- hp1(y, lambda = 1600, x_user = NULL, P_user = NULL, discard = 0)
ytrend1 <- hp1(y, lambda = 1600, x_user = NULL, P_user = NULL)
ytrend
ytrend[-1:-0,]
ytrend[0:-0,]
ytrend[-1:-0,]
ytrend[-1:-0+1,]
ytrend[-1:-2,]
ytrend[0:-2,]
ytrend[0:-0,]
ytrend[0:-1,]
ytrend[-1:-2,]
ytrend[-1:-2,]
ytrend[-1:-3,]
ytrend[-1:-0,]
ytrend[-1:-1,]
hp1 <- function(y,lambda,x_user,P_user,discard) {
kalman_update = function(y,F,H,Q,R,j,k,x,P) {
# Updates the Kalman filter estimation of the state and MSE
# For details, see Chapter 13 of Hamilton, J.D. (1994). Time Series Analysis. Princeton University Press.
S = H %*% P %*% t(H) + R
K = F %*% P %*% t(H)
K = K / as.double(S) # Kalman gain
x = F %*% x + K * as.double(y[j,k] - H %*% x) # State estimate
Temp = F - K %*% H
P = Temp %*% P %*% t(Temp)
P = P + Q + K %*% R %*% t(K) # MSE estimate
return(list("x" = x, "P" = P)) # Store the results to be returned when calling the function as a list (we do this because R functions return one result)
}
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the Kalman filtration results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600
T = nrow(y)
n = ncol(y)
# Kalman preliminaries. The notation follows Chapter 13 of Hamilton, J.D.
# (1994). Time Series Analysis. with the exception of H, which is equivalent
# to his H'.
q = 1 / lambda # the signal-to-noise ration: i.e. var eta_t / var epsilon_t
F = rbind(c(2,-1),c(1,0)) # The state transition matrix
H = rbind(c(1,0)) # The observation matrix
Q = rbind(c(q,0),c(0,0)) # The variance-covariance matrix of the errors in the state equation
R = 1 # The variance of the error in the observation equation
for (k in 1:n) { # Run the Kalman filter for each variable
if (nargs() < 4 | exists("x_user")=="FALSE" | is.null(x_user)) {x = rbind(unlist(c(2*y[1,k]-y[2,k])), unlist(c(3*y[1,k]-2*y[2,k])))} else {x = x_user[,k]} # If the user didn't provide an initial value for state estimate, extrapolate back two periods from the observations
if (nargs() < 4 | exists("P_user")=="FALSE" | is.null(P_user)) {P = rbind(c(1e5, 0), c(0,1e5))} else {P = P_user[k]} # If the user didn't provide an intial value for the MSE, set a relatively high one
for (j in 1:T) { # Get the estimates for each period
klm = kalman_update(y,F,H,Q,R,j,k,x,P) # store the results returned by the function as a list called "klm"
x = klm$x # get element "x" from the list called "klm" and store it as "x" so that it can be used outside the function kalman_update
P = klm$P # similarly to x
ytrend[j,k]=x[2] # The second element of the state is the estimate of the trend
}
}
ycycle = y - ytrend # Deviations from the HP trend
if (!missing(discard) & discard!=0) { # If the user provided a discard parameter
ytrend = ytrend[-1:-discard,] # Remove the first "discard" periods from the trend series
ycycle = ycycle[-1:-discard,] # The second output will be the deviations from the HP trend, likewise with  first "discard" periods removed
}
ytrend <- as.data.frame(ytrend) # Store "ytrend" as a tibble
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
ytrend1 <- hp1(y, lambda = 1600, x_user = NULL, P_user = NULL, discard = 0)
View(ytrend)
View(ytrend1)
ytrend2 <- hp1(y)
ytrend2 <- hp1(y, 1600)
ytrend1 <- hp1(y, lambda = 1600, x_user = NULL, P_user = NULL, discard = 0)
hp1 <- function(y,lambda,x_user,P_user,discard) {
kalman_update = function(y,F,H,Q,R,j,k,x,P) {
# Updates the Kalman filter estimation of the state and MSE
# For details, see Chapter 13 of Hamilton, J.D. (1994). Time Series Analysis. Princeton University Press.
S = H %*% P %*% t(H) + R
K = F %*% P %*% t(H)
K = K / as.double(S) # Kalman gain
x = F %*% x + K * as.double(y[j,k] - H %*% x) # State estimate
Temp = F - K %*% H
P = Temp %*% P %*% t(Temp)
P = P + Q + K %*% R %*% t(K) # MSE estimate
return(list("x" = x, "P" = P)) # Store the results to be returned when calling the function as a list (we do this because R functions return one result)
}
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the Kalman filtration results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600
T = nrow(y)
n = ncol(y)
# Kalman preliminaries. The notation follows Chapter 13 of Hamilton, J.D.
# (1994). Time Series Analysis. with the exception of H, which is equivalent
# to his H'.
q = 1 / lambda # the signal-to-noise ration: i.e. var eta_t / var epsilon_t
F = rbind(c(2,-1),c(1,0)) # The state transition matrix
H = rbind(c(1,0)) # The observation matrix
Q = rbind(c(q,0),c(0,0)) # The variance-covariance matrix of the errors in the state equation
R = 1 # The variance of the error in the observation equation
for (k in 1:n) { # Run the Kalman filter for each variable
if (nargs() < 4 | exists("x_user")=="FALSE") {x = rbind(unlist(c(2*y[1,k]-y[2,k])), unlist(c(3*y[1,k]-2*y[2,k])))} else {x = x_user[,k]} # If the user didn't provide an initial value for state estimate, extrapolate back two periods from the observations
if (nargs() < 4 | exists("P_user")=="FALSE") {P = rbind(c(1e5, 0), c(0,1e5))} else {P = P_user[k]} # If the user didn't provide an intial value for the MSE, set a relatively high one
for (j in 1:T) { # Get the estimates for each period
klm = kalman_update(y,F,H,Q,R,j,k,x,P) # store the results returned by the function as a list called "klm"
x = klm$x # get element "x" from the list called "klm" and store it as "x" so that it can be used outside the function kalman_update
P = klm$P # similarly to x
ytrend[j,k]=x[2] # The second element of the state is the estimate of the trend
}
}
ycycle = y - ytrend # Deviations from the HP trend
if (!missing(discard) & discard!=0) { # If the user provided a discard parameter
ytrend = ytrend[-1:-discard,] # Remove the first "discard" periods from the trend series
ycycle = ycycle[-1:-discard,] # The second output will be the deviations from the HP trend, likewise with  first "discard" periods removed
}
ytrend <- as.data.frame(ytrend) # Store "ytrend" as a tibble
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
ytrend2 <- hp1(y)
hp1 <- function(y,lambda,x_user,P_user,discard) {
kalman_update = function(y,F,H,Q,R,j,k,x,P) {
# Updates the Kalman filter estimation of the state and MSE
# For details, see Chapter 13 of Hamilton, J.D. (1994). Time Series Analysis. Princeton University Press.
S = H %*% P %*% t(H) + R
K = F %*% P %*% t(H)
K = K / as.double(S) # Kalman gain
x = F %*% x + K * as.double(y[j,k] - H %*% x) # State estimate
Temp = F - K %*% H
P = Temp %*% P %*% t(Temp)
P = P + Q + K %*% R %*% t(K) # MSE estimate
return(list("x" = x, "P" = P)) # Store the results to be returned when calling the function as a list (we do this because R functions return one result)
}
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the Kalman filtration results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600
T = nrow(y)
n = ncol(y)
# Kalman preliminaries. The notation follows Chapter 13 of Hamilton, J.D.
# (1994). Time Series Analysis. with the exception of H, which is equivalent
# to his H'.
q = 1 / lambda # the signal-to-noise ration: i.e. var eta_t / var epsilon_t
F = rbind(c(2,-1),c(1,0)) # The state transition matrix
H = rbind(c(1,0)) # The observation matrix
Q = rbind(c(q,0),c(0,0)) # The variance-covariance matrix of the errors in the state equation
R = 1 # The variance of the error in the observation equation
for (k in 1:n) { # Run the Kalman filter for each variable
if (nargs() < 4 | exists("x_user")=="FALSE") {x = rbind(unlist(c(2*y[1,k]-y[2,k])), unlist(c(3*y[1,k]-2*y[2,k])))} else {x = x_user[,k]} # If the user didn't provide an initial value for state estimate, extrapolate back two periods from the observations
if (nargs() < 4 | exists("P_user")=="FALSE") {P = rbind(c(1e5, 0), c(0,1e5))} else {P = P_user[k]} # If the user didn't provide an intial value for the MSE, set a relatively high one
for (j in 1:T) { # Get the estimates for each period
klm = kalman_update(y,F,H,Q,R,j,k,x,P) # store the results returned by the function as a list called "klm"
x = klm$x # get element "x" from the list called "klm" and store it as "x" so that it can be used outside the function kalman_update
P = klm$P # similarly to x
ytrend[j,k]=x[2] # The second element of the state is the estimate of the trend
}
}
ycycle = y - ytrend # Deviations from the HP trend
if (!missing(discard)) { # If the user provided a discard parameter
if (discard!=0) {
ytrend = ytrend[-1:-discard,] # Remove the first "discard" periods from the trend series
ycycle = ycycle[-1:-discard,]
}
}
ytrend <- as.data.frame(ytrend) # Store "ytrend" as a tibble
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
ytrend2 <- hp1(y)
ytrend2 <- hp1(y, 1600)
ytrend2 <- hp1(y, 1600, discard = 0)
ytrend2 <- hp1(y, 1600, discard = 1)
ytrend2 <- hp1(y, 1600, discard = 0)
View(ytrend2)
View(ytrend1)
View(ytrend1)
View(ytrend)
ytrend2 <- hp1(y, 1600, discard = 1)
View(ytrend2)
ytrend2 <- hp1(y, 1600, discard = 0)
hp2 <- function(y,lambda) {
hp2 <- function(y,lambda) {
hp2 <- function(y,lambda) {
hp2 <- function(y,lambda) {
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600;
T = nrow(y)
n = ncol(y)
# Preliminary calculations
x1=rbind(c(1+lambda, -2*lambda, lambda)) # The non-zero elements of the first row of A
x2=rbind(c(-2*lambda, 1+5*lambda, -4*lambda, lambda)) # The non-zero elements of the second row of A
x3=rbind(c(lambda, -4*lambda, 1+6*lambda, -4*lambda, lambda)) # The non-zero elements of the j'th row of A, 2<j<T-2
x2rev=x2[,ncol(x2):1] # Flip columns of matrix # The non-zero elements of the second-to-last row of A
# x2rev=x2[nrow(x2):1,] # Flip rows of matrix # The non-zero elements of the last row of A
x1rev=x1[,ncol(x1):1]
x2rev <- t(as.matrix(x2rev))
x1rev <- t(as.matrix(x1rev))
# Make a list (a column vector) containing at position i the row of the i'th non-zero element in A
I = matrix(3:(T-2), nrow = 1)
I = do.call(rbind, replicate(5, I, simplify=FALSE)) # |5| (replicate 5 times)
I = cbind(c(I))
I = rbind(1,1,1,2,2,2,2,I,T-1,T-1,T-1,T-1,T,T,T)
J = matrix(1:(T-4), nrow = 1)
J = do.call(rbind, replicate(5, J, simplify=FALSE)) # |5| (replicate 5 times)
J = cbind(c(J))
Temp = matrix(0:4, nrow = 1)
Temp = t(do.call(rbind, replicate(T-4, Temp, simplify=FALSE)))
Temp = cbind(c(Temp))
J = J + Temp
J = rbind(1,2,3,1,2,3,4,J,T-3,T-2,T-1,T,T-2,T-1,T)
# Make a list (a column vector) containing at position i the i'th non-zero element in A
X = t(do.call(rbind, replicate(T-4, x3, simplify=FALSE))) # |5| (replicate 5 times)
X = cbind(c(X))
X = rbind(t(x1),t(x2),X,t(x2rev),t(x1rev))
# Replicate vectors by the number of columns in the input dataframe
MX = t(do.call(cbind, replicate(ncol(ytrend), X, simplify=FALSE)))
MX <- t(as.matrix(MX))
MI = t(do.call(cbind, replicate(ncol(ytrend), I, simplify=FALSE)))
MI <- t(as.matrix(MI))
MJ = t(do.call(cbind, replicate(ncol(ytrend), J, simplify=FALSE)))
MJ <- t(as.matrix(MJ))
A = sparseMatrix(i=as.vector(MI),j=as.vector(MJ),x=as.vector(MX))
ytrend <- solve(A, matrix(unlist(y), ncol=ncol(y)), sparse = TRUE)
ifelse(ncol(y) == 1,
ytrend <- as.data.frame(ytrend),
ytrend <- as.data.frame(matrix(ytrend@x, ncol=ncol(y))) * ncol(y) # Store "ytrend" as a tibble
)
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
hp2 = function(y,lambda) {
hp2 <- function(y,lambda) {
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the results will be stored
hp2 <- function(y,lambda) {
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600;
T = nrow(y)
n = ncol(y)
# Preliminary calculations
x1=rbind(c(1+lambda, -2*lambda, lambda)) # The non-zero elements of the first row of A
x2=rbind(c(-2*lambda, 1+5*lambda, -4*lambda, lambda)) # The non-zero elements of the second row of A
x3=rbind(c(lambda, -4*lambda, 1+6*lambda, -4*lambda, lambda)) # The non-zero elements of the j'th row of A, 2<j<T-2
x2rev=x2[,ncol(x2):1] # Flip columns of matrix # The non-zero elements of the second-to-last row of A
# x2rev=x2[nrow(x2):1,] # Flip rows of matrix # The non-zero elements of the last row of A
x1rev=x1[,ncol(x1):1]
x2rev <- t(as.matrix(x2rev))
x1rev <- t(as.matrix(x1rev))
# Make a list (a column vector) containing at position i the row of the i'th non-zero element in A
I = matrix(3:(T-2), nrow = 1)
I = do.call(rbind, replicate(5, I, simplify=FALSE)) # |5| (replicate 5 times)
I = cbind(c(I))
I = rbind(1,1,1,2,2,2,2,I,T-1,T-1,T-1,T-1,T,T,T)
J = matrix(1:(T-4), nrow = 1)
J = do.call(rbind, replicate(5, J, simplify=FALSE)) # |5| (replicate 5 times)
J = cbind(c(J))
Temp = matrix(0:4, nrow = 1)
Temp = t(do.call(rbind, replicate(T-4, Temp, simplify=FALSE)))
Temp = cbind(c(Temp))
J = J + Temp
J = rbind(1,2,3,1,2,3,4,J,T-3,T-2,T-1,T,T-2,T-1,T)
# Make a list (a column vector) containing at position i the i'th non-zero element in A
X = t(do.call(rbind, replicate(T-4, x3, simplify=FALSE))) # |5| (replicate 5 times)
X = cbind(c(X))
X = rbind(t(x1),t(x2),X,t(x2rev),t(x1rev))
# Replicate vectors by the number of columns in the input dataframe
MX = t(do.call(cbind, replicate(ncol(ytrend), X, simplify=FALSE)))
MX <- t(as.matrix(MX))
MI = t(do.call(cbind, replicate(ncol(ytrend), I, simplify=FALSE)))
MI <- t(as.matrix(MI))
MJ = t(do.call(cbind, replicate(ncol(ytrend), J, simplify=FALSE)))
MJ <- t(as.matrix(MJ))
A = sparseMatrix(i=as.vector(MI),j=as.vector(MJ),x=as.vector(MX))
ytrend <- solve(A, matrix(unlist(y), ncol=ncol(y)), sparse = TRUE)
ifelse(ncol(y) == 1,
ytrend <- as.data.frame(ytrend),
ytrend <- as.data.frame(matrix(ytrend@x, ncol=ncol(y))) * ncol(y) # Store "ytrend" as a tibble
)
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
hp2 <- function(y,lambda) {
ytrend <- matrix(data=NA,nrow=nrow(y),ncol=ncol(y)) # Create an empty matrix of the same size as "y", where the results will be stored
if (nargs() < 2 | exists("lambda")=="FALSE")  {lambda = 1600} # If the user didn't provide a value for lambda, set it to the default value of 1600;
T = nrow(y)
n = ncol(y)
# Preliminary calculations
x1=rbind(c(1+lambda, -2*lambda, lambda)) # The non-zero elements of the first row of A
x2=rbind(c(-2*lambda, 1+5*lambda, -4*lambda, lambda)) # The non-zero elements of the second row of A
x3=rbind(c(lambda, -4*lambda, 1+6*lambda, -4*lambda, lambda)) # The non-zero elements of the j'th row of A, 2<j<T-2
x2rev=x2[,ncol(x2):1] # Flip columns of matrix # The non-zero elements of the second-to-last row of A
# x2rev=x2[nrow(x2):1,] # Flip rows of matrix # The non-zero elements of the last row of A
x1rev=x1[,ncol(x1):1]
x2rev <- t(as.matrix(x2rev))
x1rev <- t(as.matrix(x1rev))
# Make a list (a column vector) containing at position i the row of the i'th non-zero element in A
I = matrix(3:(T-2), nrow = 1)
I = do.call(rbind, replicate(5, I, simplify=FALSE)) # |5| (replicate 5 times)
I = cbind(c(I))
I = rbind(1,1,1,2,2,2,2,I,T-1,T-1,T-1,T-1,T,T,T)
J = matrix(1:(T-4), nrow = 1)
J = do.call(rbind, replicate(5, J, simplify=FALSE)) # |5| (replicate 5 times)
J = cbind(c(J))
Temp = matrix(0:4, nrow = 1)
Temp = t(do.call(rbind, replicate(T-4, Temp, simplify=FALSE)))
Temp = cbind(c(Temp))
J = J + Temp
J = rbind(1,2,3,1,2,3,4,J,T-3,T-2,T-1,T,T-2,T-1,T)
# Make a list (a column vector) containing at position i the i'th non-zero element in A
X = t(do.call(rbind, replicate(T-4, x3, simplify=FALSE))) # |5| (replicate 5 times)
X = cbind(c(X))
X = rbind(t(x1),t(x2),X,t(x2rev),t(x1rev))
# Replicate vectors by the number of columns in the input dataframe
MX = t(do.call(cbind, replicate(ncol(ytrend), X, simplify=FALSE)))
MX <- t(as.matrix(MX))
MI = t(do.call(cbind, replicate(ncol(ytrend), I, simplify=FALSE)))
MI <- t(as.matrix(MI))
MJ = t(do.call(cbind, replicate(ncol(ytrend), J, simplify=FALSE)))
MJ <- t(as.matrix(MJ))
A = sparseMatrix(i=as.vector(MI),j=as.vector(MJ),x=as.vector(MX))
ytrend <- solve(A, matrix(unlist(y), ncol=ncol(y)), sparse = TRUE)
ifelse(ncol(y) == 1,
ytrend <- as.data.frame(ytrend),
ytrend <- as.data.frame(matrix(ytrend@x, ncol=ncol(y))) * ncol(y) # Store "ytrend" as a tibble
)
colnm <- colnames(y) # Get column names from "y"
colnames(ytrend) <- colnm # Name the columns of "ytrend" so that they have the same names as "y"
return(ytrend)
}
hp2 <- function(y,lambda) {
set.seed(10)
y <- as.data.frame(rev(diffinv(rnorm(100)))[1:100])+30
colnames(y) <- "gdp"
plot(y$gdp)
plot(y$gdp, type="l")
ytrend = hp2(y)
library(Matrix)
ytrend = hp2(y)
ycycle = y - ytrend
plot(y$gdp, type="l", col="black", lty=1, ylim=c(-10,30))
lines(ytrend$gdp, col="#066462")
polygon(c(1, seq(ycycle$gdp), length(ycycle$gdp)), c(0, ycycle$gdp, 0), col = "#E0F2F1")
legend("bottom", horiz=TRUE, cex=0.75, c("y", "ytrend", "ycycle"), lty = 1,
col = c("black", "#066462", "#75bfbd"))
ytrend = hp2(y, 400000)
ycycle = y - ytrend
plot(y$gdp, type="l", col="black", lty=1, ylim=c(-10,30))
lines(ytrend$gdp, col="#066462")
polygon(c(1, seq(ycycle$gdp), length(ycycle$gdp)), c(0, ycycle$gdp, 0), col = "#E0F2F1")
legend("bottom", horiz=TRUE, cex=0.75, c("y", "ytrend", "ycycle"), lty = 1,
col = c("black", "#066462", "#75bfbd"))
setwd("..")
install("hpfilter")
library("devtools")
library("roxygen2")
install("hpfilter")
detach("package:Matrix", unload = TRUE)
library(hpfilter)
detach("package:hpfilter", unload = TRUE)
remove.packages("hpfilter")
hp1
hp1
hp1
install("hpfilter")
library(hpfilter)
?hpfilter
?hp1
?hp1
?hp2
??hp2
.libPaths()
library(hpfilter)
?hpfilter
?hp1
remove.packages("hpfilter")
library(devtools)
library(roxygen2)
document()
install("hpfilter")
setwd(..)
setwd("..")
install("hpfilter")
library(hpfilter)
?hpfilter
?hp1
?hp2
?hp2
set.seed(10)
y <- as.data.frame(rev(diffinv(rnorm(100)))[1:100])+30
colnames(y) <- "gdp"
plot(y$gdp, type="l")
ytrend = hp2(y)
remove.packages("hpfilter")
library(devtools)
library(roxygen2)
document()
setwd("..")
install("hpfilter")
library(hpfilter)
?hpfilter
data(GDPEU)
force(GDPEU)
View(GDPEU)
data(GDPEU)
?`matrix-class`
?ggplot2
library(ggplot2)
?ggplot2
remove.packages("hpfilter")
library(devtools)
library(roxygen2)
document()
setwd("..")
install("hpfilter")
library(hpfilter)
?hpfilter
remove.packages("hpfilter")
library(devtools)
library(roxygen2)
document()
setwd("..")
install("hpfilter")
library(hpfilter)
?hpfilter
?hpfilter
?hp1
set.seed(10)
y <- as.data.frame(rev(diffinv(rnorm(100)))[1:100])+30
colnames(y) <- "gdp"
plot(y$gdp, type="l")
# Apply the HP filter to the data
ytrend = hp1(y)
ycycle = y - ytrend
# Plot the three resulting series
plot(y$gdp, type="l", col="black", lty=1, ylim=c(-10,30))
lines(ytrend$gdp, col="#066462")
polygon(c(1, seq(ycycle$gdp), length(ycycle$gdp)), c(0, ycycle$gdp, 0), col = "#E0F2F1")
legend("bottom", horiz=TRUE, cex=0.75, c("y", "ytrend", "ycycle"), lty = 1,
col = c("black", "#066462", "#75bfbd"))
View(y)
write.csv(y, "y.csv")
library(hpfilter)
?hp2
set.seed(10)
y <- as.data.frame(rev(diffinv(rnorm(100)))[1:100])+30
colnames(y) <- "gdp"
plot(y$gdp, type="l")
# Apply the HP filter to the data
ytrend = hp2(y)
ycycle = y - ytrend
# Plot the three resulting series
plot(y$gdp, type="l", col="black", lty=1, ylim=c(-10,30))
lines(ytrend$gdp, col="#066462")
polygon(c(1, seq(ycycle$gdp), length(ycycle$gdp)), c(0, ycycle$gdp, 0), col = "#E0F2F1")
legend("bottom", horiz=TRUE, cex=0.75, c("y", "ytrend", "ycycle"), lty = 1,
col = c("black", "#066462", "#75bfbd"))
View(ytrend)
set.seed(10)
y <- as.data.frame(rev(diffinv(rnorm(100)))[1:100])+30
colnames(y) <- "gdp"
plot(y$gdp, type="l")
# Apply the HP filter to the data
ytrend = hp2(y, 400000)
ycycle = y - ytrend
# Plot the three resulting series
plot(y$gdp, type="l", col="black", lty=1, ylim=c(-10,30))
lines(ytrend$gdp, col="#066462")
polygon(c(1, seq(ycycle$gdp), length(ycycle$gdp)), c(0, ycycle$gdp, 0), col = "#E0F2F1")
legend("bottom", horiz=TRUE, cex=0.75, c("y", "ytrend", "ycycle"), lty = 1,
col = c("black", "#066462", "#75bfbd"))
?hp2
data(GDPEU)
head(GDPEU)
View(GDPEU)
View(GDPEU)
?hpfilter
?hpfilter
remove.packages("hpfilter")
packages(devtools)
library(devtools)
library(roxygen2)
document()
setwd("..")
install("hpfilter")
